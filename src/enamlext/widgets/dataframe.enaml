from enaml.core.declarative import d_
from atom.api import Value, Bool, Typed

from enamlext.widgets import Table
from enamlext.qt.qt_dataframe import DataFrameProxy
from enamlext.qt.table.column import generate_columns

import pandas as pd
import time

def refresh_cells(row_indexes, col_indexes):
    # t0 = time.perf_counter()
    #print('modified', row_indexes, col_indexes)
    for row, col in zip(row_indexes, col_indexes):
        self.proxy.widget.refresh_one_cell(row, col)
    # t1 = time.perf_counter()
    # print(f'It took {t1 - t0:.3f} s to refresh {len(row_indexes)} cells')


enamldef DataFrame(Table):
    attr df = None  # d_(Value(factory=pd.DataFrame))
    attr include = None   # d_(Typed(list))
    attr exclude = None   # d_(Typed(list))
    attr _auto_refresh_columns = False

    # instead of is_ticking which is going to refresh all the columns
    # it should allow to pass a list of columns that are going to be ticking
    # this will improve performance for dataframes which only a subset of
    # columns will be expected to tick/refresh
    # TODO: should this member be set only once during initialization?
    attr is_ticking = False
    attr tick_interval_ms = 100

    func convert_item(item):
        # TODO: should we return the Series? using .iloc[0] ?
        #       we could do that if we pass the whole selection context here instead
        return dict(zip(df.columns.values, item))

    func _monitor_df_changes():
        import numpy as np
        from enaml.application import deferred_call

        values = self.df.values.copy()
        interval = tick_interval_ms / 1_000

        while True:
            time.sleep(interval)
            row_indexes, col_indexes = np.where(values != self.df.values)
            deferred_call(refresh_cells, row_indexes, col_indexes)
            values = self.df.values.copy()

    func _refresh_internals():
        _df = df if self.df is not None else pd.DataFrame()
        self.items = DataFrameProxy(_df)
        if not self.columns and self._auto_refresh_columns:
            print('generating columns')
            proposed_new_columns = {(c.key, c.title): c
                                    for c in generate_columns(self.items, hints=hints,
                                                              include=self.include, exclude=self.exclude)}
            if self.proxy.widget is not None:
                filters = self.proxy.widget.model().filters
                for column in filters.filters.copy():
                    filter_key = (column.key, column.title)
                    filter = filters.filters.pop(column)

                    if filter_key in proposed_new_columns:
                        filter.column = proposed_new_columns[filter_key]
                        filters.filters[filter.column] = filter

            self.columns = list(proposed_new_columns.values())

    activated ::
        self.proxy.widget.adjust_column_sizes()  # TODO: why we need to call this here?
        if self.is_ticking:
            import threading
            t = threading.Thread(target=self._monitor_df_changes, daemon=True)
            t.start()

    initialized ::
        self._auto_refresh_columns = not bool(self.columns)
        self._refresh_internals()

    df ::
        self._refresh_internals()

    include ::
        self._refresh_internals()

    exclude ::
        self._refresh_internals()

    hints ::
        self._refresh_internals()